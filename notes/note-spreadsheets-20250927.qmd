---
title: "spreadsheets"
author: "Sharon Howard"
date: "2025-09-27"
categories: [readxl, import, wip]
execute:
  warning: false
  message: false
---

## Includes

```{r}
source(here::here('R/shared.R'))
```

## Notes

I've accumulated many bits of code for working with spreadsheets (mainly Excel; sometimes ODS), and can never remember how to use them. So this is a page to bring them together.



## Examples


### read in multiple sheets in an xlsx

there are two functions to this 

1. get a list of sheets in a spreadsheet (and name them)
2. read in selected sheets one at a time from the list using sheets$sheetname

nb:

- I've added guess to the second function because read_excel's default is hardly ever generous enough to deal with the weirdness of historical spreadsheets
- janitor::clean_names() is used for much the same reason. The names of sheets and columns in sheets are frequently hideous. 

```{r}
read_all_sheets <- function(path){
  path |>
    readxl::excel_sheets() |>
    set_names() |>
    clean_names("snake")
}

read_a_sheet <- function(sheet, path, guess=1000) {
  path |>
    readxl::read_excel(sheet = sheet, guess_max = guess) |>
    clean_names(case="snake") 
}
```




```{r}
apprentices_path <- here::here("data/apprenticeship_disputes.xlsx") 

# this will give a bunch of "New names" messages if not suppressed
apprentices_sheets <-
  apprentices_path |>
  read_all_sheets() |>
  map(read_a_sheet, path=apprentices_path, guess=10000)

apprentices_main_index <-
  apprentices_sheets$main_index
```

Occasionally there might be a lot of sheets that you want to get out of a spreadsheet, so the individual sheet$name method would get tedious.

The function `list2env()` can be used to put *all of* the sheets from the list as separate DFs into your R environment, but use that function very carefully (eg if any of the sheet names are the same as existing objects it'll overwrite them without any warning).

```{r}
## list2env(apprentices_sheets, envir = .GlobalEnv)
```


### same for ODS spreadsheets

TODO: this should work but I need to get an .ods file to test it.


```{r}
read_ods_sheets <- function(path){
  path |>
    ods_sheets() |>
    set_names()
}

read_ods_sheet <- function(sheet, path) {
  path |>
    read_ods(sheet = sheet) |>
    clean_names(case="snake") 
}

```



### write several DFs to a single spreadsheet, as separate sheets

This is quite easy, as several functions for writing spreadsheets will take a list of DFs and put them in separate tabs. 

But you have to give each element of the list a name.

You can do this by hand in list()

```{r}
list_of_dfs <-
  list(
    "petitions"=cheshire_petitions,
    "petitioners"=cheshire_petitioners
  )
```

Or you can make a vector of names to assign to the list

```{r}
list_of_unnamed_dfs <-
  list(cheshire_petitions, cheshire_petitioners)

sheet_names <- c("petitions", "petitioners")

names(list_of_unnamed_dfs) <- sheet_names 
```

If you have a DF that you want to split up by a chosen group column and write each group to a separate sheet in an xlsx, you can use dplyr::group_split() and then purrr::map() to make sheet names based on the column values.

NB:

- If the column contains NAs, you need to make a separate group_name column turning them into "na" or similar character string. 
- You might need to do some other manipulation if there are non-standard characters in column values, if you want to avoid spaces, etc etc.


```{r}
petitions_split_gender <-
cheshire_petitions |>
  mutate(grp_name = if_else(is.na(petition_gender), "na", petition_gender)) |>
  group_split(grp_name)

  petitions_split_gender |>
    map(~pull(., grp_name)) |>
    map(~unique(.)) -> names(petitions_split_gender)

# get rid of the extra grp_name col now you've finished with it
petitions_split_gender <-
petitions_split_gender |>
  map(~select(., -grp_name))
```

Then you just give the list name in the function to write the spreadsheet. 

This works with several functions

- xlsx

```{r}
 # writexl::write_xlsx(petitions_split_gender, 
 #          "path/to/petitions_gender.xlsx", 
 #          format_headers=FALSE)
```

```{r}
 # openxlsx::write.xlsx(list_dfs, 
 #                      "path/to/petitions_petitioners.xlsx", 
 #                      colNames=TRUE)
```

- ods

```{r}
 # readODS::write_ods(list_of_unnamed_dfs, 
 #                    "path/to/petitions_petitioners.ods")
```

I haven't tested it with any others.

It's quite easy to functionify if you'll need to use it repeatedly.

NB that you have to ["embrace" the group name](https://dplyr.tidyverse.org/articles/programming.html) inside the function  



```{r}
# need to make sure the output_folder exists!

# df = dataframe to be split
# group = grouping column to split on
# sheetname = name of the spreadsheet (needs to be "quoted" in the args?)

one_df_split_to_excel <- function(df, group, sheetname){
  
  file_name <- paste0(sheetname, ".xlsx")  
  file_path <- here::here("output_folder", file_name)
  
  # split the df into groups
  list_dfs <- 
    df |>
    group_split({{group}})
  
  # group name -> list name which will be used as the spreadsheet tab name
  list_dfs |>
    purrr::map(~pull(., {{group}})) |>
    purrr::map(~unique(.)) ->names(list_dfs)
   
   # write to spreadsheet
   writexl::write_xlsx(list_dfs, file_path, format_headers = FALSE)
}
```

## Resources

- [readxl workflows](https://readxl.tidyverse.org/articles/articles/readxl-workflows.html)
- [Write & Read Multiple Excel files with purrr](https://martinctc.github.io/blog/vignette-write-and-read-multiple-excel-files-with-purrr/)
